---
layout: post
title: 复杂度的一点总结
subtitle: 
date: 2020-4-24
author: yanghong
header-img: images/cover/10.jpg
tags: 
---

> 很多人自己也不知道复杂度是什么	(hhq)

$u^{1^{s^{1,^{qs}}}}$

我以前甚至以为 $\Omicron$ 和 $\Theta$  是一样的 (甚至连周佬也一直搞错了).



> 为了计算时间复杂度，我们通常会估计算法的操作单元数量，每个单元运行的时间都是相同的。因此，总运行时间和算法的操作单元数量最多相差一个常量系数。
>
> 相同大小的不同输入值仍可能造成算法的运行时间不同，因此我们通常使用算法的最坏情况复杂度，记为 T(n) ，定义为任何大小的输入 n 所需的最大运行时间。

 但是$+,-,\times,\div,\%$ 这些基本操作都肯定也都不止一次操作, 实际上并不好定义什么是一个操作单元.  精确计算$T(n)$应该是相当困难的.  

# 大$\Omicron$符号

(在算复杂度里应该只会用到无穷大渐近吧)



给出了一个函数的渐近上界



若$\exists M,x_0$ 对 $x \ge x_0$ 有 $\vert f(x) \vert \le M \vert g(x) \vert$ 成立, 则记为 $f(x) = \Omicron(g(x))$ 或 $f(x) \in \Omicron(g(x))$ 



感觉大$\Omicron$符号应该是用到最多的了,毕竟题目通常都会把时间复杂度卡到上界.

# $\Omega$ 符号

给出了一个函数的渐近下界



$f(x) = \Omega(g(x)) \iff g(x) = \Omicron(f(n))$

# $\Theta$ 符号

同时给出了上界和下界.

$f(x) = \Theta(g(x)) \iff f(x) = \Omicron(g(x)) \land f(x) = \Omega(g(x))$



那么用这些渐近符号来描述复杂度可以很方便(大$\Omicron$里面很多都可以省略掉了).

