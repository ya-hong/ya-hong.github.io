---
layout: post
title: 20170521练习赛
date: 2017-05-21
tags: 总结 COCI
cover: /images/cover/3.jpg
---



这次画风突变啊。

<!--more-->

# Task1



可以先将每一列砍掉一定高度使得最后答案变成一条直线，代码会简单很多。

最后答案高度从小到大考虑。高度每增加1，大于等于此高度的列可以少移除一个方块，对答案的贡献是-1，小于此高度的列需要多增加一个方块，对答案的贡献是1。及高于答案高度的列的个数为upper，小于的列的个数为lower，那么每一次的变化量为lower-upper。随着答案高度变大，超过某一个列的高度时，lower增大1，upper减小1，变化量增大2。

![](/images/20170521练习赛pic1.png)

然后可以画出答案的导函数大概就是这样的。只要找到变化量为0的位置，就可以求出极值，而零点对应的区间就是高度第$\frac n2$的列的高度到高度第$\frac{n}{2+1}$的列的高度-1（设n为偶数）。

解决两堆积木的问题就是把两个导函数加起来，找到零点。而这种情况下，就是 第n的高度 到 第n+1的高度-1。



<!--more-->



# Task2



第二道题应该没有第一题难吧，但是搞错题意乱整了好久。而且跟正解比起来我的想法还是很简单暴力。但是简单的想法总是容易想到的。

可以把这些圆构造成一颗树（儿子中不能有儿子的儿子）， 然后就可以$O(n)$解决了。

建树的过程是一个左右端点的二维的问题，而且要时时删除已经成为儿子的圆。那么可以用set来维护。先sort维护一维，再用set维护另一维，这样左右端点就都维护好了，然后每次删除所有儿子就好了。



# Task3



一开始的时候想了很多（这种给公式的题目总是容易让人多想），然后迟迟没有敲60分的代码。最后觉得再也想不出来了才写了60分，然后罚时就爆炸了。。。。。。。

其实如果想到 meet in the middle 就比较容易了（虽然这个逆元我估计不会求），但是由于这种题目做的少，而且从未主动写过这个方法，然后比赛的时候根本想不到。



# Task4


