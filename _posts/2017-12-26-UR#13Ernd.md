---
layout: post
title: Ernd
subtitle: UR#13
date: 2017-12-26
header-img: images/cover/13.jpg
tags: 数学 dp
author: yanghong
---

>   这里是跳蚤国中央广播电台，现在为您转播的是著名人类智慧大师 picks 博士与人工智能 betacome 之间的第二轮赛事。
>
>   这一场交锋的规则由网友 Po***QQ 提供，这位网友也将获得由不想跳的跳蚤不是好跳蚤——最强跳蚤跳跳跳公司提供的金牌跳蚤一只。
>
>   在刚刚结束的第一轮比赛中，因为 picks 博士在关键时刻出现了失误，他惜败给了 betacome。众所周知，A 先生在比赛前夕接受采访时，曾经说过相信 picks 博士可以以全胜的战绩战胜 betacome，请问 A 先生您现在怎么看？
>
>   “我仍然觉得 picks 博士的赢面要大一点，第一轮可能是因为他没有调整好心态，在比赛最后的水平堪比业余选手 m**o，这是非常反常的，如果他能够避免这样的失误的话，我觉得仍然觉得人类智慧可以取得最终的胜利。”
>
>   好，现在，我们可以看到，第二轮的比赛已经开始了，A 先生您能给我们简要介绍一下这一轮比赛的规则吗？
>
>   “好的，相信大家都玩过 osu 吧，这一场的规则来自 osu 的 ctb 模式。其实本来的规则是其他的模式，但是在 betacome 展示了它鬼畜的手速之后，经过比赛委员会的紧急讨论，决定把规则临时改成 ctb 模式。”
>
>   “简要来讲，你有一个盘子，时刻 $0$ 时你可以把盘子放到数轴上的**任何一个整数坐标处**，接着每一时刻你可以把盘子往左移动一个单位、往右移动一个单位或者不动。接着系统生成了 $n$ 个水果，第 $i$ 个水果会在第 $b_i$ 时刻出现在 $a_i$坐标处，**保证 $b_i$ 单调递增**。如果你的盘子在 $b_i$ 时刻恰好出现在 $a_i$ 处，那么就能接到这个水果。”
>
>   “最后一个水果落下后，游戏结束。分数用这个方式计算，定义变量 $K$，最开始 $K$ 是 $0$，按照顺序考虑每一个水果，如果你接到了当前水果，那么把 $K$ 加一，否则你的得分将加上 $K^2$ 并将 $K$ 清零，游戏结束后你的得分还会加上游戏结束时的 $K^2$。即你的得分是每一段连续接到水果的极长区间的长度平方和。”
>
>   好的，谢谢 A 先生，看来这场赛事的规则还是非常有趣的呀。现在我们节目组已经拿到了这场赛事中使用的水果信息（即数组 $a$ 与数组 $b$），A 先生您能帮我们计算双方可以拿到的最高分吗？
>
>   “当然，我们可以非常容易的算出来理论的最高分是****。” 出乎意料地，AcrossTheSky 居然一下子就说出了答案。
>
>   了解 AcrossTheSky 真实智力的你觉得这非常反常，你有理由怀疑 AcrossTheSky 是随便报了一个数字出来。所以你决定亲自计算一下答案，来检验一下 AcrossTheSky 是不是在瞎 BB。


## 简单的 $n^2$ 写法

设计一个简单的dp. 

定义: $g_{m,p}$ 表示当前考虑物品为 $m$, 上一个被取的物品为 $p$, 在区间$[m,n]$ 中能取到的最大值. $f_{m,c}$ 表示取物品 $m$ ,且该物品是某一个区间的第$c$个物品 , 那么在区间$[m,n]$ 中能取得的最大价值. 

很容易写出它的转移方程:

$$
\begin{align*}
f_{m,c} &= \max
	\begin{cases}
		g_{m+1,m}+2c-1\\
		f_{m+1,c+1} + 2c-1 &(\vert a_{m+1}-a_m\vert \le b_{m+1}-b_m)
	\end{cases}
\\
g_{m,p} &= \max 
	\begin{cases}
		g_{m+1,p}\\
		f_{m,1} &(\vert a_m-a_p\vert \le b_m-b_p)
	\end{cases}

\end{align*}
$$

## 忽略一些限制

假如 $a_i$ 很小, 可以直接记录再某个水果出现时的位置. 那么求 $g$ 的过程就简化了, 考虑如何求 $f$ . 

设 $R_{x}$ 表示一个连续区间的起点为 $x$ ,  能到达的最远位置. 它可以递推求出:

$$
R_{x} = 
\begin{cases}
x\\
R_{x+1} &(\|a_{x+1}-a_x\| \le b_{x+1}-b_{x})
\end{cases}
$$

那么可以有另一种求 $f$ 的方法, 这时要修改一下, $f_{m}$ 表示一段连续接到水果的区间的起点为m, 在 $[m,n]$ 能取得的最大值. 

$$
\begin{align*}
f_{i} 
&= \max\limits_{j=i}^{R_{i}} (g_{j+1,j} + (j-i+1)^2)\\
&= \max\limits_{j=i}^{R_{i}} (g_{j+1,j} + i^2 - 2ij + j^2 -2i + 2j + 1) \\
&= (i-1)^2 + \max\limits_{j=i}^{R_{i}} (- 2ij + j^2 + 2j + g_{j+1,j} ) \\
\end{align*}
$$

把 $(2j, j^2 + 2j + g_{j+1,j} )$ 看做是二维平面上的一个点, $-i$ 看做是一条直线的斜率, 维护凸包. 由于每次加入的点的横坐标是单调递减的, 而斜率是递增的, 所以只需要一个栈来维护, 每次在末尾增加删除元素和查询. 


## 神奇的转化

考虑如何优化求 $g$ . 修改一下, $g(m)$ 表示在 $b_m$ 时刻位于 $a_m$ 位置, $[m+1,n]$中能取得的最大价值. 

$$
\begin{align*}
g(i) &= \max\limits_{j=i+1}^{n} f(j) &(\vert a_j-a_i \vert \le b_j-b_i) \\
f(i) &= \max\limits_{j=i}^{R_i} (g(j) + (j-i+1)^2)\\
\end{align*}
$$

考虑化简它转移的限制条件:

$$
\begin{cases}
i < j\\
\vert a_j-a_i \vert \le b_j-b_i\\
\end{cases}
$$

由于$b$是单调递增的, 若满足 $\vert a_{j}-a_{i} \vert \le b_{j} - b_{i}$ , 其实也一定满足 $i<j$ . 而 $\vert a_{j}-a_{i} \vert \le b_{j} - b_{i}$ 可以拆成:

$$
\begin{align*}
b_i - a_i \le b_j - a_j\\
b_i + a_i \le b_j + a_j\\
\end{align*}
$$

可以排序+树状数组维护. 

按照 $b_i - a_i$ (或$b_i+a_i$) 排序后, 下标可能不是连续的, 但是可以保证同一段中的元素相对顺序不变, 仍然可以用前面的优化. 

