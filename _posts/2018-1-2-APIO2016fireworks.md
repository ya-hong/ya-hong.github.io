---
layout: post
title: Fireworks
subtitle: APIO 2016
date: 2018-1-2
header-img: images/cover/1.jpg
tags: 数学 数据结构
author: yanghong
---

## 转化问题

**答案一定是分段单调的下凸包**

对于$n=1$的情况. 对于$n \not = 1$的情况, 可以考虑从$n=1$的情况转移得到(从子树合并到整颗树). 相当于有两个操作:

1. 在一颗子树的树根向上连一条边
2. 合并若干颗(1)中的树

可以说明在这样的操作后答案还是一个凸包. 那么原问题就转化为维护凸包的问题了. 

**说明操作后仍是凸包**: $n=1$的情况下, 答案是下凸包. 设原有一个凸包$h(x)$, 考虑经过两个操作后的函数$h\prime(x)$:

1.  树根向上连接一条长度为$w$的边.
    设斜率为$0$的区间为$[l,r]$

    $$
    \begin{align*}
    	h\prime(x)  = 
    		\begin{cases}
    			h(x)+w &&(x \le l)\\
    			h(l)+(l+w-x) &&(l<x\le l+w)\\
    			h(l)+w &&(l+w < x \le r+w)\\
    			h(r)+(x-r-w) &&(r+w < x)
    		\end{cases}
    \end{align*}
    $$

    由于当斜率不为$0$时,$k \ge 1$, 所以$\vert h(x)-h(y) \vert \ge \vert x-y \vert ~~~(x,y \le l \lor x,y \ge r)$所以可以得到如此的方程.
    从这个方程也可以看出$h\prime(x)$是一个凸包, 凸包的最右边的三段斜率为$-1,0,1$.

2.  合并若干个凸包. 凸包满足$k_i \le k_j ~~(i<j)$即斜率不严格递增. 两个单调递增函数相加后仍为单调递增的函数, 所以斜率仍然满足不严格递增, $h\prime(x)$还是凸包. 

## 一些性质和维护

+ 凸包上有若干斜率的转折点. 可以假设从左到右扫描时, 经过每个转折点后斜率都加$1$. 由于可以使得转折点重合, 这样做是没问题的(即若斜率增加为$k$, 则有$k$个转折点重合). 
+ 由于经过每个转折点后斜率都加$1$, 所以两个凸包合并相当于合并两个凸包的转折点, 相当于我们在维护斜率的导数. (额外维护起始段或末段斜率)
+ 每经过(1)操作后, 凸包的右端的斜率为$1$. ($h\prime(x)$的最后一段为$h\prime(x) = h(r)+(x-r-w)$). 那么, 经过(2)操作后, 凸包右端的斜率为其直接连接的儿子数. 这样我们也解决了求末段斜率的问题. 


所以现在要做的就是维护转折点的横坐标(即维护斜率的导数). 考虑如何维护:

1. 对于第一种操作, 我们需要找到$k=0$的区间$[l,r]$. 弹出$l$以及之后的所有点, 如此最右端斜率为$-1$, 再加入$l+w$(它对应了斜率为$0$的一段)与$r+w$(它对应了斜率为$1$的一段).
2. 对于第二种操作, 我们要合并两个序列. 

考虑如何找到$k=0$的区间. 需要弹出$\mathrm{sz}_x +1$个最大横坐标($\mathrm{sz}_x$为$x$的子树的大小), 最后弹出的两个分别为$l$和$r$. 那么我们需要一个堆来维护. 由于还要实现合并两个序列, 所以需要可合并堆(左偏树). 

## 具体的实现

维护$n+m$颗左偏树. 从从大向小枚举. 对于每个点对应的子树, 找到它$k=0$的区间$[l,r]$, 弹出$l$以及之后的所有点, 再加入$l+w$与$r+w$. 然后将其横坐标序列与父亲的横坐标序列合并. 最后可以得到$1$号点的凸包.

那么如何计算答案? 我们已经可以知道$h(x)​$每一段的斜率, 那么只需要求出$h(0)​$ 的值, 就可以计算出$h(x)​$的最小值. 而对于$1​$号节点, $h(0)​$就等于所有的边权之和. 
