---
layout: post
title: TopCoder Div.1 Mid 450 8题
subtitle: SRM548 - SRM551 - SRM573 - SRM574 - SRM579 - SRM588 - SRM589 - SRM593 
date: 2017-04-12
header-img: images/cover/7.jpg
tags: TopCoder dp
author: yanghong
---


# SRM548 Div1Medium KingdomAndDice

$$
p=\sum_{i=0,j=0}^{n-1} \frac{(ai>bj)}{n^2}
$$

设$cnti$,为$\sum_{j=0}^n (ai>bj)$,所以：
$$
p=\sum_{i=0}^{n-1} \frac{(ai>bj)}{n^2}
$$
$ai$不等于$0$时，$cnti$是确定的。当$ai$等于$0$时，$cnti$不能确定，但是可以确定$cnti$可以取的值和该值可取的个数。于是可以通过**dp**计算出可能的$\sum_{i=0}^{n-1} \frac{(ai>bj)}{n^2}$,然后就可以计算出最优的$p$值。



然后dp有很多种方法。



### 算法一

记录$dp[cnt][val]$,表示使用$cnt$个$0$，$\sum_{i=0}^{n-1} \frac{(ai>bj)}{n^2}$能否达到$val$这个值。那么只需要枚举每一个可能的$cnti$取值，然后$O(cnt*val)$的更新就好了。$cnt$的最大值为$n$,$val$的最大值为$n^2$。虽然$cnti$有$10^9$个，但是同一个值的$cnti$超$n$个就没有意义了，所以$cnti$也只有$n^2$个,那么复杂度就达到了$n^5$。虽然这样不够快，但是也不用担心，这样的dp的优化方法还是很多的，随便搞搞就好了。



### 算法二

由于并不需要把所有的$0$都改掉，所以可以有另外的做法。原来定义的$dp[cnt][val]$，存的只是`true`或是`false`，这样是很浪费的，我们可以把可以贪心的一维，比如说第一维，直接放进$dp$值里面，来直接的降低复杂度。那么现在的$dp[val]$，就变成了达到$\sum_{i=0}^{n-1} \frac{(ai>bj)}{n^2}=val$时使用的最小的$0$的数量。虽然最终效果差不多，但是这种方法明显比上一种高多了（至少后面还会经常用到这种方法）





# SRM551 Div1Medium ColorfulWolves

这题还是比较水的`-_-||`

最后答案的路径在经过$n-1$之前肯定是没有环的。所以，我们可以把所有的$colormap[i][j]$路径都建在一张图上（因为最后答案肯定不会经过同一个i两次），然后直接跑最短路就可以了。

# SRM573 Div1Medium Ski Resorts

不管权值增大还是减小，最优情况下肯定与某一点的值相同。那么设一个点$p(i,j)$，为$i$号点权值为点$j$的权值。然后在这些$p(i,j)$点上跑Dijsktra就好了。

（不过要注意下内存）


# SRM573 Div1Medium PolygonTraversal

看到 $n \in [4,18]$,那肯定是状压了。令$dp[S]$为已经连边的点集为$S$，方案的个数。那么然后肯定就是怎么判断是否与边相交的问题了。由于所有边都是连接的，那么只有而且只要当新加入的边将原来的点集划分成两半，那么肯定与某些边相交。然后就可以很容易的dp解决了。


# SRM579 Div1Medium TravellingPurchasingMan

一开始看到这题我就直接想到了状压，但是一看$n=50$，我直接就**mengbier**!了。结果发现$p \le min(n,16)$，`-_-||`。都不知道它n为什么要放这么大……

定义$dp[S][t]$为是否能在t时间内购买出一个$S$集合。然后我们可以直接用Floyd求出一个点到一个点的最短距离，那么就可很好的转移了。不过这个t太了放不下，但是$t$肯定是尽量小好啊！所以直接把$t$往$dp$值里一丢就好了。那么就得到了新的$dp[S]$,它表示购买出一个$S$集合所花的最小时间，然后用刷表法转移就可以了。

# SRM588 Div1Medium KeyDungeonDiv1

### 4维dp
朴素的4维dp很容易想出来: $dp[S][R][G][W]$表示当前已经开门的集合为$S$,钥匙为$R$，$G$，$W$时是否可行。当然这样炸的飞起。

### 3维dp
很容易可以缩掉一维。由于已经知道了开门集合$S$，所以可以很容易推出钥匙总数，所以只需要知道两种钥匙的的数量就可以知道另一种，那么就可以随便去掉一维。

### 2维dp
其实正解还是用到了第一题的那种方法由于白色钥匙是万能钥匙，所以在总量一定的情况下肯定是白色钥匙越多越好。那么直接记录$dp[S][R]=W$为当前已经开门的集合为$S$,钥匙为$R$，最多的白钥匙数量。这样就可以解决了。（所以第一次没有定义好状态的时候要想想一些优化状态定义的方法，比如像这种交换dp值和dp下标的方法）

# SRM589 Div1Medium GearsDiv1

首先可以知道，最优情况下，肯定是两种颜色同一个方向，另一种不同方向。如果三种全部同种方向，那么所有点都不能两边，那么肯定也满足了前一种情况。所以两种颜色同一个方向，另一种不同方向肯定不会劣。

假设$R$,$G$,同方向，$B$不同方向。由于每种颜色内部不连边，所以$B$可以任意连边。然后$R$和$G$不能连边。其实$R$和$G$,可以当做两个集合，可以构成一个二分图，那么剩下的互补连边点的个数就相当于这个二分图的最大独立集，删除的点的个数等于最大匹配数。那么分三种情况讨论一下取最大匹配的最小值就可以了。

# SRM593 Div1Medium MayTheBestPetWin

$$
maxdiff(S1,S2)=max ( \sum_{i \in S1} bi - \sum_{j \in S2} aj , \sum_{j \in S2} bj - \sum_{i \in S1} ai )
$$

$$
maxdiff(S1,S2)=max(  \sum_{i \in S1} (ai+bi) - \sum ak , \sum bk - \sum_{i \in S2} (ai+bi)  )
$$

dp枚举出所有可能$ai+bi$,然后取$min$就好了。
